#!/bin/bash

#变量定义
ip_array=("192.168.1.1" "192.168.1.2" "192.168.1.3")
user="test1"
remote_cmd="/home/test/1.sh"

#本地通过ssh执行远程服务器的脚本
for ip in ${ip_array[*]}
do
	if [ $ip = "192.168.1.1" ]; then
		port="7777"
	else
		port="22"
	fi
	ssh -t -p $port $user@$ip "remote_cmd" #向远程机器发送命令
done

#!/bin/sh
#echo "waring"
#read NAME #等待用户输入并把输入的值付给NAME
#NAME=$1 #将脚本第一个参数赋给NAME
#引用变量时加上"{}",是个好习惯,利于shell辨别变量边界
if [ ${NAME} = "jingzhongzhi" ];then #如果NAME中的值为"jingzhongzhi"，则继续执行if
ls -l
else #否则就执行else
ssh -t -p 22 localhost "ls /" #向远程机器发送命令
fi #结束if命令

readonly NAME #设置为只读变量不能被再次赋值、修改
unset  NAME #删除变量，不能删除只读变量
echo  $$查看当前shell的pid

变量	含义
$0	当前脚本的文件名
$n	传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。
$#	传递给脚本或函数的参数个数。
$*	传递给脚本或函数的所有参数。
$@	传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同，下面将会讲到。
$?	上个命令的退出状态，或函数的返回值。
$$	当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。


#####################################
$* 和 $@ 的区别

$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(" ")包含时，都以"$1" "$2" … "$n" 的形式输出所有参数。

但是当它们被双引号(" ")包含时，"$*" 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数；"$@" 会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数。

#####################################
退出状态

$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。

退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。

不过，也有一些命令返回其他值，表示不同类型的错误。

#####################################

echo -e 表示对转义字符进行替换。如果不使用 -e 选项，将会原样输出

转义字符	含义
\\	反斜杠
\a	警报，响铃
\b	退格（删除键）
\f	换页(FF)，将当前位置移到下页开头
\n	换行
\r	回车
\t	水平制表符（tab键） 
\v	垂直制表符

##############################
变量作为整数相加减
N=1
$(($N+1))  或者 $[$N+1]
这样变量就会做为整数相加减了

#################################
if [ ! -n $NUM ] #判断变量NUm是否为空,为空执行if

#######函数#######
## function 可有可无,遵循C的规则，函数定义在调用之前，调用时直接使用函数名
function fun_name(){

}
fun_name #调用函数
